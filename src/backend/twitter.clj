(ns backend.twitter
  (:require
   [clojure.java.io    :as io]
   [clojure.edn        :as edn]
   [cljs.closure       :as cljsc]
   [org.httpkit.server :as httpkit]
   [taoensso.carmine   :as car]))

;;;
;;; Redis connection
;;;
(defmacro with-redis [& body] `(car/wcar {} ~@body))

;;;
;;; Data layout: http://redis.io/topics/twitter-clone
;;;

;;; User creation

(def user-model {:user-id   "" ; <= generated by Redis INCR
                 :username  "" 
                 :password  ""
                 :followers #{}
                 :following #{}})

(defn- random-str [] (.toString (java.util.UUID/randomUUID)))

(defn next-user-id []
  (with-redis (car/incr :next_user_id)))

(defn create-user [username password]
  (let [user-id (next-user-id)
        auth    (random-str)]
    (with-redis
      (car/hset :users username user-id) ; for lookups of user-id by username
      (car/hset :auths auth user-id)     ; for auth cookie lookups
      (car/hmset* (str "user:" user-id)
                  {:username username
                   :password password
                   :auth     auth}))))

;;; Followers

(defn- now [] (System/currentTimeMillis))

(defn follow [follower-id user-id]
  (with-redis
    (car/zadd (str "followers:" user-id) (now) follower-id)
    (car/zadd (str "following:" follower-id) (now) user-id)))

;;; Registering updates

(defn post [user-id post-id]
  (with-redis
    (car/lpush (str "posts:" user-id) post-id)))

;;; Authentication

(defn get-user-id [username]
  (with-redis (car/hget :users username)))

(defn authenticate [username password]
  (when-let [user-id (get-user-id username)]
    (let [user-key (str "user:" user-id)]
      (when (= password (with-redis (car/hget user-key :password)))
        {:username username
         :user-id  user-id
         :auth     (with-redis (car/hget user-key :auth))}))))

(defn- get-user-auth [user-id]
  (car/hget (str "user:" user-id) :auth))

(defn logged-in? [user-id auth]
  (let [[user-id* auth*] (with-redis
                           (car/hget :auths auth)
                           (get-user-auth user-id))]
    (and (= user-id user-id*) (= auth auth*))))

(defn logout [user-id]
  (let [new-auth (random-str)]
    (with-redis
      (let [old-auth (get-user-auth user-id)]
        (car/hdel :auths old-auth)
        (car/hset :auths new-auth user-id)
        (car/hset (str "user:" user-id) :auth new-auth)))))

;;; Creating updates

(defn next-post-id []
  (with-redis (car/incr :next_post_id)))

(defn followers-for [user-id]
  (with-redis
    (car/zrange (str "followers:" user-id) 0 -1)))

(defn record-post [user-id post-id ts content]
  (with-redis
    (car/hmset* (str "post:" post-id)
                {:user_id user-id
                 :time    ts
                 :body    content})))

(defn broadcast-post [user-id post-id]
  (doseq [follower-id (followers-for user-id)]
    (post follower-id post-id)))

(defn update-timeline [post-id]
  (with-redis
    (car/lpush :timeline post-id)
    (car/ltrim :timeline 0 1000)))

(defn create-post [user-id post-id content]
  (let [post-id (next-post-id)]
    (record-post user-id post-id (now) content)
    (broadcast-post user-id post-id)
    (update-timeline post-id)))

;;; Retrieving updates w/ pagination

(defn paginate-posts [user-id start how-many]
  (let [redis-key (if user-id (str "posts:" user-id) :timeline)]
    (with-redis
      (car/lrange redis-key start (+ start how-many)))))


;;;
;;; HTTP API
;;;
(def html
  {:status  200
   :headers {"Content-Type" "text/html"}
   :body "
<!doctype html>
<html>
<head><meta charset=\"utf-8\"><title>Retwis</title></head>
<body>
<div id=\"root\"></div>
<script src=\"react.js\"></script>
<script src=\"app.js\"></script>
</body>
</html>"})

(def not-found
  {:status  404
   :headers {"Content-Type" "text/plain"}
   :body    "Not found"})

(defn handle-login
  "Set a cookie and return the user-id"
  [req]
  (let [{:keys [username password]} (edn/read-string (slurp (:body req)))]
    (when-let [{:keys [user-id auth]} (authenticate username password)]
      {:status  200
       :headers {"Content-Type" "application/edn"
                 "Set-Cookie"   (str "auth=" auth)}
       :body    (pr-str {:user-id user-id})})))

(defn handle-logout
  "Delete the cookie and its record in Redis"
  [req]
  (let [{:keys [username]} (edn/read-string (slurp (:body req)))]
    (logout (get-user-id username))
    {:status  204
     :headers {}
     :body    nil}))

(defn handle-auth [{method :request-method :as req}]
  (when (#{:post :delete} method)
    (case method
      :post   (handle-login req)
      :delete (handle-logout req))))

(defn resource [type path]
  {:status  200
   :headers {"Content-Type" (type {:js   "application/javascript"
                                   :css  "text/css"
                                   :html "text/html"})}
   :body    (slurp (io/resource path))})

(def cached-resource
  (memoize resource))

(declare websocket)

(defn new-http-server [& [port]]
  (httpkit/run-server
   (fn app [{uri :uri :as req}]
     (println {:ts (java.util.Date.) :uri uri})
     (or (case uri
           "/"         html
           "/auth"     (handle-auth req)
           "/react.js" (cached-resource :js "reagent/react.min.js")
           "/app.js"   (resource :js "app.js")
           "/ws"       (websocket req)
           nil)
         not-found))
   {:port (or port 3000)}))

;;;
;;; Websocket API
;;;

(defonce connected-uids (atom #{}))

(defn websocket [req]
  (httpkit/with-channel req channel
    (httpkit/on-close channel   (fn [status] (println req status)))
    (httpkit/on-receive channel (fn [data] (httpkit/send! channel (str "saw: " data))))))

;;;
;;; Frontend compilation
;;;

;; (def browser-repl-conn
;;   (str "\n\n(js* \"goog.require('weasel.repl');\")\n\n"
;;        "(when-not (weasel.repl/alive?)\n"
;;        "  (weasel.repl/connect \"ws://localhost:9001\" :verbose true))"))

;; (defn compile-cljs [src opts]
;;   (do (print "Compiling" src "... ")
;;       (try (cljsc/build src opts)
;;            (print "done!\n\n")
;;            (catch Exception e
;;              (print "uh-oh!\n\n") (print e)))))

;; (defn run-cljs-compiler
;;   "In dev-mode, injects REPL-connection code"
;;   [out & [dev-mode?]]
;;   (let [src-dev    "src/retwis/.frontend_dev.cljs"
;;         src-orig   "src/retwis/frontend.cljs"
;;         src        (if dev-mode? src-dev src-orig)
;;         target     (str out "/app.js")
;;         opts       {:optimizations (if dev-mode? :whitespace :advanced)
;;                     :pretty-print  (if dev-mode? true false)
;;                     :output-to     target}]
;;     (.mkdirs (io/file out))
;;     (when dev-mode?
;;       (spit src (str (slurp src-orig) browser-repl-conn)))
;;     (compile-cljs src opts)
;;     (when-let [dev (and dev-mode? (io/file src-dev))]
;;       (when (.exists dev)
;;         (.delete dev))))

;;;
;;; Main
;;;

;; (defn -main [& [port]]
;;   (compile-cljs)
;;   (run-http-server port)))
